using System.Collections.Generic;
using System.Linq;
using System.Text;
using Logsmith.Generator.Models;

namespace Logsmith.Generator.Emission;

internal static class MethodEmitter
{
    private static readonly string[] LogLevelNames =
    {
        "Trace", "Debug", "Information", "Warning", "Error", "Critical", "None"
    };

    internal static string EmitClassFile(
        string namespaceName,
        IReadOnlyList<ContainingTypeInfo> typeChain,
        IReadOnlyList<LogMethodInfo> methods)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        // Emit inner content at zero indent, then re-indent for nesting depth
        var innerSb = new StringBuilder();

        // Emit CategoryName constant
        var category = methods[0].Category;
        innerSb.AppendLine($"    public const string CategoryName = \"{EscapeString(category)}\";");

        for (int i = 0; i < methods.Count; i++)
        {
            if (i > 0) innerSb.AppendLine();
            innerSb.Append(EmitMethodBody(methods[i]));
        }

        // Emit static counter fields for sampling/rate-limiting
        foreach (var method in methods)
        {
            var counterFields = EmitStaticCounterFields(method);
            if (!string.IsNullOrEmpty(counterFields))
            {
                innerSb.AppendLine();
                innerSb.Append(counterFields);
            }
        }

        // Emit state structs for methods with structured dispatch
        foreach (var method in methods)
        {
            if (!method.HasExplicitSink)
            {
                var stateStruct = EmitStateStruct(method);
                if (!string.IsNullOrEmpty(stateStruct))
                {
                    innerSb.AppendLine();
                    innerSb.Append(stateStruct);
                }
            }
        }

        // Emit WriteProperties methods for structured dispatch
        foreach (var method in methods)
        {
            if (!method.HasExplicitSink)
            {
                var writeProps = StructuredPathEmitter.EmitWritePropertiesMethod(method);
                if (!string.IsNullOrEmpty(writeProps))
                {
                    innerSb.AppendLine();
                    innerSb.Append(writeProps);
                }
            }
        }

        // Calculate base indent for innermost class content
        // Outer classes add indent; the innermost class body content gets (chainLength - 1) * 4 extra spaces
        int extraIndent = (typeChain.Count - 1) * 4;
        string extraIndentStr = extraIndent > 0 ? new string(' ', extraIndent) : "";

        // Open nesting wrappers (outermost first)
        for (int i = 0; i < typeChain.Count; i++)
        {
            string indent = i > 0 ? new string(' ', i * 4) : "";
            sb.AppendLine($"{indent}{typeChain[i].Modifiers}partial {typeChain[i].Keyword} {typeChain[i].Name}");
            sb.AppendLine($"{indent}{{");
        }

        // Re-indent inner content
        string innerContent = innerSb.ToString();
        if (extraIndent > 0)
        {
            var lines = innerContent.Split('\n');
            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i];
                // Preserve empty lines as-is (may have trailing \r)
                string trimmed = line.TrimEnd('\r');
                if (trimmed.Length == 0)
                    sb.AppendLine();
                else
                    sb.AppendLine(extraIndentStr + trimmed);
            }
        }
        else
        {
            sb.Append(innerContent);
        }

        // Close nesting wrappers (innermost first)
        for (int i = typeChain.Count - 1; i >= 0; i--)
        {
            string indent = i > 0 ? new string(' ', i * 4) : "";
            sb.AppendLine($"{indent}}}");
        }

        return sb.ToString();
    }

    internal static string EmitMethodBody(LogMethodInfo method)
    {
        var sb = new StringBuilder();
        string levelName = method.Level >= 0 && method.Level < LogLevelNames.Length
            ? LogLevelNames[method.Level]
            : "Information";

        // Conditional attribute
        int threshold = ConditionalCompilation.ParseThreshold(method.ConditionalLevel);
        bool applyConditional = ConditionalCompilation.ShouldApplyConditional(
            method.Level, threshold, method.AlwaysEmit);

        if (applyConditional)
        {
            sb.AppendLine("    [global::System.Diagnostics.Conditional(\"DEBUG\")]");
        }

        // Method signature
        sb.Append($"    {method.AccessModifier}static partial void {method.MethodName}(");
        sb.Append(string.Join(", ", method.Parameters.Select(p => FormatParameter(p))));
        sb.AppendLine(")");
        sb.AppendLine("    {");

        // IsEnabled early-exit guard
        if (method.HasExplicitSink)
        {
            var sinkParam = method.Parameters.First(p => p.Kind == ParameterKind.Sink);
            sb.AppendLine($"        if (!{sinkParam.Name}.IsEnabled(global::Logsmith.LogLevel.{levelName}))");
            sb.AppendLine("            return;");
        }
        else
        {
            sb.AppendLine($"        if (!global::Logsmith.LogManager.IsEnabled(global::Logsmith.LogLevel.{levelName}, \"{EscapeString(method.Category)}\"))");
            sb.AppendLine("            return;");
        }

        // Sampling guard
        if (method.SampleRate > 1)
        {
            sb.AppendLine();
            sb.Append(EmitSamplingGuard(method));
        }

        // Rate-limiting guard
        if (method.MaxPerSecond > 0)
        {
            sb.AppendLine();
            sb.Append(EmitRateLimitGuard(method));
        }

        sb.AppendLine();

        // LogEntry construction
        sb.Append(EmitLogEntryConstruction(method));
        sb.AppendLine();

        // Text path
        int bufferSize = EstimateBufferSize(method);
        sb.AppendLine($"        global::System.Span<byte> __buffer = stackalloc byte[{bufferSize}];");
        sb.AppendLine("        var writer = new global::Logsmith.Utf8LogWriter(__buffer);");
        sb.Append(TextPathEmitter.Emit(method));
        sb.AppendLine("        var __utf8Message = writer.GetWritten();");
        sb.AppendLine();

        // Dispatch
        if (method.HasExplicitSink)
        {
            var sinkParam = method.Parameters.First(p => p.Kind == ParameterKind.Sink);
            sb.AppendLine($"        {sinkParam.Name}.Write(in __entry, __utf8Message);");
        }
        else
        {
            // Create state and dispatch
            string stateTypeName = $"{method.MethodName}State";
            var messageParams = method.Parameters.Where(p => p.Kind == ParameterKind.MessageParam).ToList();

            sb.Append($"        var __state = new {stateTypeName}(");
            sb.Append(string.Join(", ", messageParams.Select(p => $"{p.RefKind}{p.Name}")));
            sb.AppendLine(");");
            sb.AppendLine($"        global::Logsmith.LogManager.Dispatch(in __entry, __utf8Message, __state, WriteProperties_{method.MethodName});");
        }

        sb.AppendLine("    }");
        return sb.ToString();
    }

    internal static string EmitLogEntryConstruction(LogMethodInfo method)
    {
        var sb = new StringBuilder();
        string levelName = method.Level >= 0 && method.Level < LogLevelNames.Length
            ? LogLevelNames[method.Level]
            : "Information";

        // Find special parameters
        string exceptionExpr = "null";
        string callerFileExpr = "null";
        string callerLineExpr = "0";
        string callerMemberExpr = "null";

        foreach (var param in method.Parameters)
        {
            switch (param.Kind)
            {
                case ParameterKind.Exception:
                    exceptionExpr = param.Name;
                    break;
                case ParameterKind.CallerFile:
                    callerFileExpr = param.Name;
                    break;
                case ParameterKind.CallerLine:
                    callerLineExpr = param.Name;
                    break;
                case ParameterKind.CallerMember:
                    callerMemberExpr = param.Name;
                    break;
            }
        }

        sb.AppendLine("        var __entry = new global::Logsmith.LogEntry(");
        sb.AppendLine($"            level: global::Logsmith.LogLevel.{levelName},");
        sb.AppendLine($"            eventId: {method.EventId},");
        sb.AppendLine("            timestampTicks: global::System.DateTime.UtcNow.Ticks,");
        sb.AppendLine($"            category: \"{EscapeString(method.Category)}\",");
        sb.AppendLine($"            exception: {exceptionExpr},");
        sb.AppendLine($"            callerFile: {callerFileExpr},");
        sb.AppendLine($"            callerLine: {callerLineExpr},");
        sb.AppendLine($"            callerMember: {callerMemberExpr},");
        sb.AppendLine("            threadId: global::System.Environment.CurrentManagedThreadId,");
        sb.AppendLine("            threadName: global::System.Threading.Thread.CurrentThread.Name);");

        return sb.ToString();
    }

    internal static string EmitStateStruct(LogMethodInfo method)
    {
        var messageParams = method.Parameters.Where(p => p.Kind == ParameterKind.MessageParam).ToList();

        var sb = new StringBuilder();
        string stateTypeName = $"{method.MethodName}State";

        sb.AppendLine($"    private readonly ref struct {stateTypeName}");
        sb.AppendLine("    {");

        if (messageParams.Count > 0)
        {
            // Fields
            foreach (var param in messageParams)
            {
                string fieldType = FormatType(param);
                sb.AppendLine($"        internal readonly {fieldType} {param.Name};");
            }

            sb.AppendLine();

            // Constructor
            sb.Append($"        internal {stateTypeName}(");
            sb.Append(string.Join(", ", messageParams.Select(p =>
            {
                string paramType = FormatType(p);
                return $"{p.RefKind}{paramType} {p.Name}";
            })));
            sb.AppendLine(")");
            sb.AppendLine("        {");
            foreach (var param in messageParams)
            {
                sb.AppendLine($"            this.{param.Name} = {param.Name};");
            }
            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        return sb.ToString();
    }

    internal static int EstimateBufferSize(LogMethodInfo method)
    {
        int size = 0;

        foreach (var part in method.TemplateParts)
        {
            if (!part.IsPlaceholder)
            {
                // Literal: UTF-8 byte count (approximate as chars for ASCII)
                size += part.Text.Length;
            }
            else if (part.BoundParameter != null)
            {
                var param = part.BoundParameter;
                if (part.FormatSpecifier == "json")
                    size += 256;
                else if (param.TypeFullName == "global::System.String" || param.TypeFullName == "string")
                    size += 128;
                else
                    size += 32;
            }
        }

        // Minimum and maximum bounds
        if (size < 128) size = 128;
        if (size > 4096) size = 4096;

        return size;
    }

    private static string FormatParameter(ParameterInfo param)
    {
        string type = FormatType(param);

        // Caller info: attributes are on the user's definition part already.
        // Don't emit default values on the implementation â€” they have no effect
        // on partial method implementations and produce CS1066.
        if (param.Kind is ParameterKind.CallerFile or ParameterKind.CallerLine or ParameterKind.CallerMember)
            return $"{type} {param.Name}";

        if (param.HasDefaultValue)
        {
            string defaultStr = param.DefaultValue == null ? "default" : param.DefaultValue.ToString();
            return $"{param.RefKind}{type} {param.Name} = {defaultStr}";
        }

        return $"{param.RefKind}{type} {param.Name}";
    }

    private static string FormatType(ParameterInfo param)
    {
        string type = param.TypeFullName;
        if (param.IsNullableValueType)
            type = $"{type}?";
        else if (param.IsNullableReferenceType)
            type = $"{type}?";
        return type;
    }

    internal static string EmitSamplingGuard(LogMethodInfo method)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"        if ((global::System.Threading.Interlocked.Increment(ref __sampleCounter_{method.MethodName}) % {method.SampleRate}) != 0)");
        sb.AppendLine("            return;");
        return sb.ToString();
    }

    internal static string EmitRateLimitGuard(LogMethodInfo method)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"        long __nowSeconds_{method.MethodName} = global::System.DateTime.UtcNow.Ticks / global::System.TimeSpan.TicksPerSecond;");
        sb.AppendLine($"        long __window_{method.MethodName} = global::System.Threading.Volatile.Read(ref __rateWindow_{method.MethodName});");
        sb.AppendLine($"        if (__nowSeconds_{method.MethodName} != __window_{method.MethodName})");
        sb.AppendLine("        {");
        sb.AppendLine($"            global::System.Threading.Interlocked.Exchange(ref __rateWindow_{method.MethodName}, __nowSeconds_{method.MethodName});");
        sb.AppendLine($"            global::System.Threading.Interlocked.Exchange(ref __rateCount_{method.MethodName}, 0);");
        sb.AppendLine("        }");
        sb.AppendLine($"        if (global::System.Threading.Interlocked.Increment(ref __rateCount_{method.MethodName}) > {method.MaxPerSecond})");
        sb.AppendLine("            return;");
        return sb.ToString();
    }

    internal static string EmitStaticCounterFields(LogMethodInfo method)
    {
        var sb = new StringBuilder();

        if (method.SampleRate > 1)
        {
            sb.AppendLine($"    private static int __sampleCounter_{method.MethodName};");
        }

        if (method.MaxPerSecond > 0)
        {
            sb.AppendLine($"    private static long __rateWindow_{method.MethodName};");
            sb.AppendLine($"    private static int __rateCount_{method.MethodName};");
        }

        return sb.ToString();
    }

    private static string EscapeString(string text)
    {
        return text
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r");
    }
}
